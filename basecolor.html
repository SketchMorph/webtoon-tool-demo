<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Webtoon Auto Flat v4 (Face→Neck Skin + Arm Skin)</title>
  <style>
    :root{
      --bg:#0b0d12; --panel:#121622; --panel2:#171c2b;
      --text:#e9eefc; --muted:#9aa6c4; --line:#27304a;
      --accent:#79a7ff; --good:#35d07f; --bad:#ff5a6a; --warn:#ffd38a;
    }
    *{box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{margin:0; background:var(--bg); color:var(--text);}
    .app{display:grid; grid-template-columns: 360px 1fr 420px; height:100vh;}
    .left,.right{background:var(--panel); overflow:auto;}
    .left{border-right:1px solid var(--line);}
    .right{border-left:1px solid var(--line);}
    .mid{background:#0f1320; overflow:hidden; display:flex; flex-direction:column;}
    header{padding:14px 16px; border-bottom:1px solid var(--line); background:linear-gradient(180deg,var(--panel),transparent);}
    h1{margin:0; font-size:14px; letter-spacing:.3px; color:var(--muted);}
    .section{padding:14px 16px; border-bottom:1px solid var(--line);}
    .section h2{margin:0 0 10px; font-size:13px; color:#cfd7ef;}
    .hint{font-size:12px; color:var(--muted); line-height:1.5;}
    .row{display:flex; gap:10px; align-items:center; margin:8px 0;}
    input[type="text"], input[type="number"], select{
      width:100%; padding:10px 10px; border:1px solid var(--line);
      background:var(--panel2); color:var(--text); border-radius:10px;
    }
    button{
      padding:10px 12px; border:1px solid var(--line); background:var(--panel2);
      color:var(--text); border-radius:10px; cursor:pointer;
    }
    button.primary{background:rgba(121,167,255,.18); border-color:rgba(121,167,255,.35);}
    button.good{background:rgba(53,208,127,.16); border-color:rgba(53,208,127,.35);}
    button.bad{background:rgba(255,90,106,.14); border-color:rgba(255,90,106,.35);}
    button:disabled{opacity:.55; cursor:not-allowed;}
    .pill{
      font-size:12px; color:var(--muted); padding:6px 10px;
      border:1px solid var(--line); border-radius:999px; background:rgba(23,28,43,.7);
    }
    .midTop{
      padding:10px 12px; border-bottom:1px solid var(--line);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background:linear-gradient(180deg, rgba(18,22,34,.85), rgba(18,22,34,.2));
    }
    .stage{
      flex:1; display:grid; grid-template-columns: 1fr 1fr; gap:10px;
      padding:10px; overflow:auto;
    }
    .canvasCard{
      border:1px solid var(--line); border-radius:16px; background:rgba(18,22,34,.55);
      overflow:hidden; display:flex; flex-direction:column; min-height: 320px;
    }
    .canvasCard .bar{
      padding:10px 12px; border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      background:rgba(23,28,43,.75);
    }
    .canvasCard .bar b{font-size:12px;}
    .canvasWrap{position:relative; flex:1; background:#0a0d16;}
    .canvasWrap canvas{width:100%; height:100%; display:block;}
    .thumbs{display:grid; grid-template-columns:repeat(3,1fr); gap:8px;}
    .thumb{
      border:1px solid var(--line); border-radius:12px; overflow:hidden;
      background:var(--panel2); cursor:pointer; position:relative;
    }
    .thumb.selected{outline:2px solid var(--accent);}
    .thumb canvas{width:100%; height:auto; display:block;}
    .thumb .cap{position:absolute; left:8px; bottom:8px; font-size:11px; color:#dbe6ff; background:rgba(0,0,0,.35); padding:4px 6px; border-radius:8px;}
    .chips{display:flex; flex-wrap:wrap; gap:8px;}
    .chip{
      border:1px solid var(--line); background:rgba(23,28,43,.7);
      border-radius:999px; padding:6px 10px; font-size:12px;
      display:flex; gap:8px; align-items:center; cursor:pointer;
    }
    .sw{width:16px; height:16px; border-radius:6px; border:1px solid rgba(255,255,255,.25);}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .divider{height:1px; background:var(--line); margin:10px 0;}
    .ok{color:var(--good);} .warn{color:var(--warn);} .badTxt{color:var(--bad);}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px; color:#cfe0ff; background:rgba(121,167,255,.12); border:1px solid rgba(121,167,255,.25);
      padding:2px 6px; border-radius:6px; display:inline-block; margin:2px 0;
    }
    details{border:1px solid var(--line); border-radius:12px; padding:10px; background:rgba(23,28,43,.35);}
    summary{cursor:pointer; color:#cfd7ef; font-size:12px;}
  </style>
</head>
<body>
<div class="app">
  <!-- LEFT -->
  <aside class="left">
    <header><h1>컷 리스트</h1></header>

    <div class="section">
      <h2>1) 통짜 선화 업로드 → 자동 컷 분할</h2>
      <div class="hint">
        웹툰 1화 세로본(선화) 이미지 1장을 올리면 자동으로 컷을 분할합니다.<br/>
        <span class="kbd">v4</span> 컷 생성 후 상/하단 흰 여백 자동 트림(가능한 경우).
      </div>

      <div class="row">
        <input id="longInput" type="file" accept="image/*"/>
      </div>

      <div class="row">
        <button id="btnSplit" class="primary">자동 컷 분할</button>
        <button id="btnExportMeta">episode.meta.json</button>
      </div>

      <div class="hint" id="splitStats">업로드 대기…</div>

      <details style="margin-top:10px;">
        <summary>고급(디버그) — 컷 분할 진단 보기</summary>
        <div class="hint" id="splitDiag" style="margin-top:8px;">-</div>
      </details>
    </div>

    <div class="section">
      <h2>2) 컷 선택</h2>
      <div class="hint">썸네일 클릭 → 가운데 미리보기/채색/다운로드</div>
      <div class="thumbs" id="thumbs"></div>
    </div>
  </aside>

  <!-- MID -->
  <main class="mid">
    <div class="midTop">
      <span class="pill" id="currentCutPill">선택된 컷: 없음</span>
      <span class="pill">모드: 통짜 → 컷분할 → 캐릭터코드만 → 자동 밑색</span>
      <span class="pill">룰: 얼굴→목 skin, 상의양옆 팔 skin</span>
      <span class="pill" id="statusPill">대기</span>
    </div>

    <div class="stage">
      <div class="canvasCard">
        <div class="bar">
          <b>선화 (현재 컷)</b>
          <span class="hint" id="lineInfo">-</span>
        </div>
        <div class="canvasWrap"><canvas id="cvLine"></canvas></div>
      </div>

      <div class="canvasCard">
        <div class="bar">
          <b>밑색 결과 (auto flats)</b>
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="btnRender" class="good">렌더</button>
            <button id="btnDownloadCut">현재 컷 PNG</button>
            <button id="btnDownloadAll" class="primary">전체 ZIP</button>
          </div>
        </div>
        <div class="canvasWrap"><canvas id="cvOut"></canvas></div>
      </div>

      <div class="canvasCard">
        <div class="bar">
          <b>레퍼런스(기준 채색 컷)</b>
          <span class="hint">스포이드로 팔레트 저장</span>
        </div>
        <div class="canvasWrap"><canvas id="cvRef"></canvas></div>
      </div>

      <div class="canvasCard">
        <div class="bar">
          <b>디버그</b>
          <span class="hint">영역/그룹 + 얼굴/목/팔 표시</span>
        </div>
        <div class="canvasWrap"><canvas id="cvDbg"></canvas></div>
      </div>
    </div>
  </main>

  <!-- RIGHT -->
  <aside class="right">
    <header><h1>캐릭터 팔레트 / 컷 정보</h1></header>

    <div class="section">
      <h2>3) 기준 채색 이미지 업로드</h2>
      <div class="row">
        <input id="refInput" type="file" accept="image/*"/>
      </div>
      <div class="hint">
        ① 캐릭터 선택 → ② 파트 버튼 선택 → ③ 레퍼런스 이미지 클릭 = 색 저장<br/>
        <span class="kbd">추천</span> skin / hair / brow / eye_iris / eye_white / mouth / top / bottom / bg
      </div>
    </div>

    <div class="section">
      <h2>4) 캐릭터 관리</h2>
      <div class="row">
        <input id="charName" type="text" placeholder="캐릭터 코드 (예: 좌1, 우1)"/>
      </div>
      <div class="row">
        <button id="btnAddChar" class="primary">+ 캐릭터 추가</button>
        <button id="btnExportPalette">palette.json</button>
      </div>

      <div class="row">
        <label style="min-width:90px;">선택 캐릭터</label>
        <select id="charSelect"></select>
      </div>

      <div class="hint" id="charHint">캐릭터를 추가하세요.</div>
    </div>

    <div class="section">
      <h2>5) 팔레트 스포이드 (디테일)</h2>
      <div class="chips" id="partButtons"></div>

      <div class="row">
        <label style="min-width:90px;">선택 파트</label>
        <select id="partSelect"></select>
      </div>

      <div class="row">
        <label style="min-width:90px;">tolerance</label>
        <input id="tolInput" type="number" value="16" min="0" max="80"/>
      </div>

      <div class="chips" id="paletteChips"></div>

      <div class="divider"></div>
      <div class="hint">
        <b>v4 상체 skin 규칙</b><br/>
        - 얼굴 후보를 찾고, <b>얼굴 바로 아래 & 인접</b> 영역을 목(skin)으로 강제<br/>
        - 상의(top) 후보를 찾고, <b>상의와 인접 & 좌/우로 튀어나간</b> 영역을 팔(skin)으로 강제<br/>
      </div>
    </div>

    <div class="section">
      <h2>6) 현재 컷 등장 캐릭터</h2>
      <div class="hint">컷마다 등장 캐릭터만 체크하면, 후보 영역을 좌→우로 그룹핑해 적용합니다.</div>
      <div id="cutCharChecklist" class="grid2"></div>
      <div class="row">
        <button id="btnSaveCutChars" class="primary">현재 컷 캐릭터 저장</button>
      </div>
      <div class="hint" id="cutCharHint">-</div>

      <div class="divider"></div>
      <div class="hint">
        <b class="warn">주의</b>: 인물 1명 컷은 1명만 체크할수록 안정적입니다.
      </div>
    </div>

    <div class="section">
      <h2>7) 로그</h2>
      <div class="hint" id="renderHint">-</div>
    </div>
  </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<script>
/** =========================
 *  STATE
 *  ========================= */
const state = {
  episodeId: "EP001",
  longImg: null,
  longCanvas: null,
  cuts: {},
  cutOrder: [],
  selectedCutId: null,

  characters: {},
  selectedChar: null,

  refImg: null,

  parts: [
    { key:"bg", label:"배경" },
    { key:"skin", label:"피부" },
    { key:"hair", label:"머리" },
    { key:"brow", label:"눈썹" },
    { key:"eye_iris", label:"눈동자(홍채)" },
    { key:"eye_white", label:"흰자" },
    { key:"mouth", label:"입" },
    { key:"top", label:"상의" },
    { key:"bottom", label:"하의" }
  ],
  selectedPart: "skin",
};

/** =========================
 *  DOM
 *  ========================= */
const longInput = document.getElementById("longInput");
const btnSplit = document.getElementById("btnSplit");
const splitStats = document.getElementById("splitStats");
const splitDiag = document.getElementById("splitDiag");

const thumbs = document.getElementById("thumbs");
const currentCutPill = document.getElementById("currentCutPill");
const statusPill = document.getElementById("statusPill");
const lineInfo = document.getElementById("lineInfo");
const renderHint = document.getElementById("renderHint");

const cvLine = document.getElementById("cvLine");
const cvOut = document.getElementById("cvOut");
const cvRef = document.getElementById("cvRef");
const cvDbg = document.getElementById("cvDbg");

const refInput = document.getElementById("refInput");
const charName = document.getElementById("charName");
const btnAddChar = document.getElementById("btnAddChar");
const charSelect = document.getElementById("charSelect");
const charHint = document.getElementById("charHint");

const partButtons = document.getElementById("partButtons");
const partSelect = document.getElementById("partSelect");
const tolInput = document.getElementById("tolInput");
const paletteChips = document.getElementById("paletteChips");

const cutCharChecklist = document.getElementById("cutCharChecklist");
const btnSaveCutChars = document.getElementById("btnSaveCutChars");
const cutCharHint = document.getElementById("cutCharHint");

const btnExportPalette = document.getElementById("btnExportPalette");
const btnExportMeta = document.getElementById("btnExportMeta");

const btnRender = document.getElementById("btnRender");
const btnDownloadCut = document.getElementById("btnDownloadCut");
const btnDownloadAll = document.getElementById("btnDownloadAll");

/** =========================
 *  HELPERS
 *  ========================= */
function setStatus(txt){ statusPill.textContent = txt; }
function fileToImage(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}
function rgbToHex(r,g,b){
  const to = (v)=>v.toString(16).padStart(2,"0");
  return `#${to(r)}${to(g)}${to(b)}`;
}
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
}
function downloadJson(obj, filename){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  saveAs(blob, filename);
}
function drawContain(ctx, img, canvas){
  const cw = canvas.width, ch = canvas.height;
  const iw = img.width, ih = img.height;
  const s = Math.min(cw/iw, ch/ih);
  const w = iw*s, h = ih*s;
  const x = (cw-w)/2, y=(ch-h)/2;
  ctx.clearRect(0,0,cw,ch);
  ctx.drawImage(img, x,y,w,h);
  return {x,y,w,h, scale:s, iw, ih};
}
function canvasClickToImageXY(evt, canvas, draw){
  const rect = canvas.getBoundingClientRect();
  const mx = (evt.clientX - rect.left) * (canvas.width / rect.width);
  const my = (evt.clientY - rect.top) * (canvas.height / rect.height);
  const {x,y,w,h, iw, ih} = draw;
  if(mx < x || my < y || mx > x+w || my > y+h) return null;
  const nx = (mx - x) / w, ny = (my - y) / h;
  return { ix: Math.floor(nx*iw), iy: Math.floor(ny*ih) };
}
function ensureChar(code){
  if(!state.characters[code]){
    state.characters[code] = { displayName: code, palette: {} };
  }
}
function percentile(arr, p){
  if(arr.length===0) return 0;
  const a = [...arr].sort((x,y)=>x-y);
  const idx = Math.min(a.length-1, Math.max(0, Math.floor((a.length-1)*p)));
  return a[idx];
}
function movingAverage(src, win){
  const n = src.length;
  const dst = new Float32Array(n);
  const w = Math.max(1, win|0);
  let sum = 0;
  let q = [];
  for(let i=0;i<n;i++){
    sum += src[i];
    q.push(src[i]);
    if(q.length > w) sum -= q.shift();
    dst[i] = sum / q.length;
  }
  return dst;
}

/** === small util === */
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function overlap1D(a0,a1,b0,b1){
  const lo = Math.max(a0,b0);
  const hi = Math.min(a1,b1);
  return Math.max(0, hi-lo);
}

/** =========================
 *  CUT TRIM (problem1)
 *  ========================= */
function trimVerticalWhitespace(srcCanvas){
  const W = srcCanvas.width, H = srcCanvas.height;
  const ctx = srcCanvas.getContext("2d");
  const img = ctx.getImageData(0,0,W,H).data;

  const brightRow = (y)=>{
    let bright=0, valid=0;
    for(let x=0;x<W;x++){
      const i=(y*W+x)*4;
      const a=img[i+3]; if(a===0) continue;
      valid++;
      const lum=(img[i]+img[i+1]+img[i+2])/3;
      if(lum>248) bright++;
    }
    if(valid===0) return true;
    return (bright/valid) > 0.985;
  };

  const minBand = Math.max(10, Math.floor(H*0.01));

  let top=0;
  while(top<H){
    let ok=true;
    for(let k=0;k<minBand;k++){
      if(top+k>=H) break;
      if(!brightRow(top+k)){ ok=false; break; }
    }
    if(ok) top+=minBand;
    else break;
  }

  let bottom=H-1;
  while(bottom>=0){
    let ok=true;
    for(let k=0;k<minBand;k++){
      if(bottom-k<0) break;
      if(!brightRow(bottom-k)){ ok=false; break; }
    }
    if(ok) bottom-=minBand;
    else break;
  }

  top = clamp(top,0,H-1);
  bottom = clamp(bottom,top,H-1);
  const newH = (bottom-top+1);

  const out = document.createElement("canvas");
  out.width = W;
  out.height = newH;
  out.getContext("2d").drawImage(srcCanvas, 0, top, W, newH, 0, 0, W, newH);
  return out;
}

/** =========================
 *  1D KMEANS (problem3 group mixing)
 *  ========================= */
function kmeans1D(values, K, iters=12){
  const v = values.slice();
  if(v.length===0) return {centers:[], labels:[]};
  v.sort((a,b)=>a-b);

  const centers = [];
  for(let k=0;k<K;k++){
    const idx = Math.floor((v.length-1) * (k/(K-1 || 1)));
    centers.push(v[idx]);
  }

  const labels = new Array(values.length).fill(0);

  for(let it=0; it<iters; it++){
    for(let i=0;i<values.length;i++){
      let best=0, bestD=1e9;
      for(let k=0;k<K;k++){
        const d=Math.abs(values[i]-centers[k]);
        if(d<bestD){ bestD=d; best=k; }
      }
      labels[i]=best;
    }
    const sum=new Array(K).fill(0);
    const cnt=new Array(K).fill(0);
    for(let i=0;i<values.length;i++){
      const k=labels[i];
      sum[k]+=values[i];
      cnt[k]+=1;
    }
    for(let k=0;k<K;k++){
      if(cnt[k]>0) centers[k]=sum[k]/cnt[k];
    }
  }
  return {centers, labels};
}

/** =========================
 *  PALETTE / PARTS UI
 *  ========================= */
function renderPartsUI(){
  partButtons.innerHTML = "";
  partSelect.innerHTML = "";
  for(const p of state.parts){
    const btn = document.createElement("button");
    btn.textContent = p.label;
    btn.className = (state.selectedPart === p.key) ? "primary" : "";
    btn.onclick = ()=>{ state.selectedPart = p.key; renderPartsUI(); renderPaletteChips(); };
    partButtons.appendChild(btn);

    const opt = document.createElement("option");
    opt.value = p.key; opt.textContent = `${p.label} (${p.key})`;
    partSelect.appendChild(opt);
  }
  partSelect.value = state.selectedPart;
}
partSelect.addEventListener("change", ()=>{
  state.selectedPart = partSelect.value;
  renderPartsUI();
  renderPaletteChips();
});

function refreshCharSelect(){
  const codes = Object.keys(state.characters);
  charSelect.innerHTML = "";
  if(codes.length === 0){
    const o = document.createElement("option");
    o.value=""; o.textContent="(없음)";
    charSelect.appendChild(o);
    state.selectedChar = null;
    charHint.textContent = "캐릭터를 추가하세요. 예: 좌1, 우1";
    renderPaletteChips();
    refreshCutCharChecklist();
    return;
  }
  for(const code of codes){
    const opt = document.createElement("option");
    opt.value = code; opt.textContent = code;
    charSelect.appendChild(opt);
  }
  if(!state.selectedChar || !state.characters[state.selectedChar]) state.selectedChar = codes[0];
  charSelect.value = state.selectedChar;
  charHint.innerHTML = `선택 캐릭터: <b class="ok">${state.selectedChar}</b>`;
  renderPaletteChips();
  refreshCutCharChecklist();
}
charSelect.addEventListener("change", ()=>{
  state.selectedChar = charSelect.value || null;
  refreshCharSelect();
});
btnAddChar.addEventListener("click", ()=>{
  const code = (charName.value || "").trim();
  if(!code) return alert("캐릭터 코드를 입력하세요. 예: 좌1, 우1");
  ensureChar(code);
  state.selectedChar = code;
  charName.value="";
  refreshCharSelect();
});

function renderPaletteChips(){
  paletteChips.innerHTML = "";
  if(!state.selectedChar) return;

  const ch = state.characters[state.selectedChar];
  const keys = Object.keys(ch.palette);
  if(keys.length === 0){
    const div = document.createElement("div");
    div.className="hint";
    div.textContent="팔레트가 없습니다. 파트 선택 후 레퍼런스 이미지에서 클릭하세요.";
    paletteChips.appendChild(div);
    return;
  }

  const order = state.parts.map(p=>p.key);
  keys.sort((a,b)=> order.indexOf(a) - order.indexOf(b));

  for(const partKey of keys){
    const entry = ch.palette[partKey];
    const pMeta = state.parts.find(p=>p.key===partKey);
    const label = pMeta ? pMeta.label : partKey;

    const chip = document.createElement("div");
    chip.className="chip";
    const sw = document.createElement("div");
    sw.className="sw";
    sw.style.background = entry.hex;

    const txt = document.createElement("div");
    txt.innerHTML = `<div><b>${label}</b> <span class="hint">(${partKey})</span></div>
                     <div class="hint">${entry.hex} / tol ${entry.tol}</div>`;
    chip.appendChild(sw);
    chip.appendChild(txt);

    chip.onclick = ()=>{
      state.selectedPart = partKey;
      renderPartsUI();
      partSelect.value = partKey;
      tolInput.value = String(entry.tol ?? 16);
    };
    paletteChips.appendChild(chip);
  }
}

/** =========================
 *  REFERENCE EYEDROPPER
 *  ========================= */
let refDraw = null;
refInput.addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  setStatus("레퍼런스 로딩…");
  const img = await fileToImage(f);
  state.refImg = img;

  cvRef.width = 900; cvRef.height = 600;
  const ctx = cvRef.getContext("2d");
  refDraw = drawContain(ctx, img, cvRef);
  setStatus("레퍼런스 OK");
});

cvRef.addEventListener("click", (evt)=>{
  if(!state.refImg || !refDraw) return alert("레퍼런스 이미지를 먼저 업로드하세요.");
  if(!state.selectedChar) return alert("캐릭터를 먼저 추가/선택하세요.");

  const pos = canvasClickToImageXY(evt, cvRef, refDraw);
  if(!pos) return;

  const off = document.createElement("canvas");
  off.width = state.refImg.width;
  off.height = state.refImg.height;
  const octx = off.getContext("2d");
  octx.drawImage(state.refImg, 0, 0);
  const pix = octx.getImageData(pos.ix, pos.iy, 1, 1).data;
  const hex = rgbToHex(pix[0],pix[1],pix[2]);

  const tol = parseInt((tolInput.value||"16").toString(),10);
  ensureChar(state.selectedChar);
  state.characters[state.selectedChar].palette[state.selectedPart] = { hex, tol: isFinite(tol)? tol : 16 };

  renderPaletteChips();
});

/** =========================
 *  UPLOAD LONG IMAGE
 *  ========================= */
longInput.addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  setStatus("선화 로딩…");
  state.longImg = await fileToImage(f);

  const off = document.createElement("canvas");
  off.width = state.longImg.width;
  off.height = state.longImg.height;
  const ctx = off.getContext("2d");
  ctx.drawImage(state.longImg, 0, 0);
  state.longCanvas = off;

  splitStats.innerHTML = `업로드됨: <b class="ok">${state.longImg.width}×${state.longImg.height}</b> → "자동 컷 분할" 클릭`;
  setStatus("선화 OK");
});

/** =========================
 *  AUTO SPLIT (Adaptive + no UI options)
 *  ========================= */
btnSplit.addEventListener("click", async ()=>{
  if(!state.longCanvas) return alert("통짜 선화 이미지를 먼저 업로드하세요.");
  setStatus("컷 분할 중…");

  const W = state.longCanvas.width;
  const H = state.longCanvas.height;

  const targetW = 900;
  const scale = Math.min(1, targetW / W);
  const w = Math.max(200, Math.floor(W * scale));
  const h = Math.max(200, Math.floor(H * scale));

  const ds = document.createElement("canvas");
  ds.width = w; ds.height = h;
  const dctx = ds.getContext("2d");
  dctx.drawImage(state.longCanvas, 0, 0, w, h);

  const img = dctx.getImageData(0,0,w,h).data;

  const darkRatio = new Float32Array(h);
  const brightRatio = new Float32Array(h);

  for(let y=0;y<h;y++){
    let dark=0, bright=0, valid=0;
    for(let x=0;x<w;x++){
      const i = (y*w + x)*4;
      const a = img[i+3];
      if(a===0) continue;
      valid++;
      const r=img[i], g=img[i+1], b=img[i+2];
      const lum = (r+g+b)/3;
      if(lum < 235) dark++;
      if(lum > 248) bright++;
    }
    const denom = Math.max(1, valid);
    darkRatio[y] = dark / denom;
    brightRatio[y] = bright / denom;
  }

  const win = Math.max(5, Math.floor(h * 0.004));
  const darkS = movingAverage(darkRatio, win);
  const brightS = movingAverage(brightRatio, win);

  const p10 = percentile(Array.from(darkS), 0.10);
  const p25 = percentile(Array.from(darkS), 0.25);
  const darkThr = Math.min(0.04, Math.max(p10 + 0.008, (p25*0.75)));
  const brightThr = 0.70;

  const minGap = Math.max(18, Math.floor(h * 0.012));
  const minCut = Math.max(90, Math.floor(h * 0.060));

  const blank = new Uint8Array(h);
  for(let y=0;y<h;y++){
    blank[y] = (darkS[y] <= darkThr && brightS[y] >= brightThr) ? 1 : 0;
  }

  const gaps = [];
  let y=0;
  while(y<h){
    if(blank[y]===1){
      const y0=y;
      while(y<h && blank[y]===1) y++;
      const y1=y-1;
      if((y1-y0+1) >= minGap) gaps.push({y0,y1});
    }else y++;
  }

  const bounds = [];
  let curStart = 0;
  for(const g of gaps){
    const end = g.y0;
    if(end - curStart >= minCut){
      bounds.push({y0:curStart, y1:end});
    }
    curStart = g.y1 + 1;
  }
  if(h - curStart >= minCut){
    bounds.push({y0:curStart, y1:h});
  }

  if(bounds.length <= 1){
    const fallbackBlank = new Uint8Array(h);
    const fbDarkThr = Math.min(0.06, Math.max(p10 + 0.012, p25));
    const fbMinGap = Math.max(minGap, Math.floor(h * 0.018));
    for(let yy=0;yy<h;yy++){
      fallbackBlank[yy] = (darkS[yy] <= fbDarkThr) ? 1 : 0;
    }
    const fbGaps = [];
    let yy=0;
    while(yy<h){
      if(fallbackBlank[yy]===1){
        const a0=yy;
        while(yy<h && fallbackBlank[yy]===1) yy++;
        const a1=yy-1;
        if((a1-a0+1) >= fbMinGap) fbGaps.push({y0:a0,y1:a1});
      }else yy++;
    }

    const fbBounds = [];
    let s0=0;
    for(const g of fbGaps){
      const end=g.y0;
      if(end - s0 >= minCut) fbBounds.push({y0:s0,y1:end});
      s0 = g.y1+1;
    }
    if(h - s0 >= minCut) fbBounds.push({y0:s0,y1:h});

    if(fbBounds.length > bounds.length){
      bounds.length = 0;
      bounds.push(...fbBounds);
    }
  }

  state.cuts = {};
  state.cutOrder = [];

  const cutInfos = bounds.map((b, idx)=>{
    const oy0 = Math.max(0, Math.floor(b.y0 / scale));
    const oy1 = Math.min(H, Math.floor(b.y1 / scale));
    return { cutId: `CUT-${String(idx+1).padStart(3,"0")}`, y0: oy0, y1: oy1 };
  });

  for(const c of cutInfos){
    const ch = c.y1 - c.y0;
    if(ch < 20) continue;
    let crop = document.createElement("canvas");
    crop.width = W;
    crop.height = ch;
    const cctx = crop.getContext("2d");
    cctx.drawImage(state.longCanvas, 0, c.y0, W, ch, 0, 0, W, ch);

    // ✅ v4: 트림 적용(가능하면 여백 제거)
    crop = trimVerticalWhitespace(crop);

    state.cuts[c.cutId] = { ...c, cropCanvas: crop, cutChars: [], renderCache: null };
    state.cutOrder.push(c.cutId);
  }

  splitStats.innerHTML = `분할 완료: <b class="ok">${state.cutOrder.length}컷</b> (Adaptive + Trim)`;
  splitDiag.innerHTML =
    `분석 스케일: ${w}×${h} (scale=${scale.toFixed(3)})<br/>`+
    `darkThr=${darkThr.toFixed(4)}, brightThr=${brightThr.toFixed(2)}, minGap=${minGap}px, minCut=${minCut}px<br/>`+
    `gap 후보: ${gaps.length}개 / bound: ${bounds.length}개<br/>`;

  await renderThumbnails();
  if(state.cutOrder.length) selectCut(state.cutOrder[0]);

  setStatus("컷 분할 OK");
});

/** =========================
 *  THUMBNAILS
 *  ========================= */
async function renderThumbnails(){
  thumbs.innerHTML = "";
  for(const cutId of state.cutOrder){
    const cut = state.cuts[cutId];
    const card = document.createElement("div");
    card.className="thumb";
    card.onclick = ()=>selectCut(cutId);

    const c = document.createElement("canvas");
    c.width = 220; c.height = 220;
    const ctx = c.getContext("2d");
    ctx.fillStyle="#0a0d16"; ctx.fillRect(0,0,c.width,c.height);

    const img = cut.cropCanvas;
    const iw = img.width, ih = img.height;
    const s = Math.min(c.width/iw, c.height/ih);
    const ww = iw*s, hh = ih*s;
    const x = (c.width-ww)/2, y=(c.height-hh)/2;
    ctx.drawImage(img, x,y,ww,hh);

    const cap = document.createElement("div");
    cap.className="cap";
    cap.textContent = cutId;

    card.appendChild(c);
    card.appendChild(cap);
    thumbs.appendChild(card);
  }
  updateThumbSelection();
}
function updateThumbSelection(){
  const nodes = thumbs.querySelectorAll(".thumb");
  nodes.forEach((n,i)=>{
    const cutId = state.cutOrder[i];
    n.classList.toggle("selected", cutId === state.selectedCutId);
  });
}

/** =========================
 *  SELECT CUT
 *  ========================= */
let lineDraw = null;
function selectCut(cutId){
  state.selectedCutId = cutId;
  updateThumbSelection();

  const cut = state.cuts[cutId];
  currentCutPill.textContent = `선택된 컷: ${cutId}`;
  lineInfo.textContent = `${cut.cropCanvas.width}×${cut.cropCanvas.height}`;

  cvLine.width = 900; cvLine.height = 600;
  cvOut.width  = 900; cvOut.height  = 600;
  cvDbg.width  = 900; cvDbg.height  = 600;

  const ctxLine = cvLine.getContext("2d");
  lineDraw = drawContain(ctxLine, cut.cropCanvas, cvLine);

  cvOut.getContext("2d").clearRect(0,0,cvOut.width,cvOut.height);
  cvDbg.getContext("2d").clearRect(0,0,cvDbg.width,cvDbg.height);

  refreshCutCharChecklist();
  cutCharHint.textContent = `현재 컷 등장 캐릭터: ${cut.cutChars.length ? cut.cutChars.join(", ") : "(없음)"}`;
  renderHint.textContent = "렌더를 눌러 자동 밑색을 확인하세요.";
}

/** =========================
 *  CUT CHARACTER CHECKLIST
 *  ========================= */
function refreshCutCharChecklist(){
  cutCharChecklist.innerHTML = "";
  const codes = Object.keys(state.characters);
  if(!state.selectedCutId){
    cutCharHint.textContent = "컷을 먼저 선택하세요.";
    return;
  }
  const cut = state.cuts[state.selectedCutId];

  if(codes.length === 0){
    cutCharChecklist.innerHTML = `<div class="hint">캐릭터를 먼저 추가하세요.</div>`;
    return;
  }

  for(const code of codes){
    const wrap = document.createElement("label");
    wrap.style.display="flex";
    wrap.style.gap="10px";
    wrap.style.alignItems="center";
    wrap.style.padding="10px";
    wrap.style.border="1px solid var(--line)";
    wrap.style.borderRadius="12px";
    wrap.style.background="rgba(23,28,43,.55)";
    wrap.style.cursor="pointer";

    const cb = document.createElement("input");
    cb.type="checkbox";
    cb.checked = cut.cutChars.includes(code);
    cb.onchange = ()=>{
      if(cb.checked && !cut.cutChars.includes(code)) cut.cutChars.push(code);
      if(!cb.checked) cut.cutChars = cut.cutChars.filter(x=>x!==code);
      cutCharHint.textContent = `현재 컷 등장 캐릭터: ${cut.cutChars.length ? cut.cutChars.join(", ") : "(없음)"}`;
      cut.renderCache = null;
    };

    const txt = document.createElement("div");
    txt.innerHTML = `<b>${code}</b><div class="hint">캐릭터 코드</div>`;
    wrap.appendChild(cb);
    wrap.appendChild(txt);
    cutCharChecklist.appendChild(wrap);
  }
}
btnSaveCutChars.addEventListener("click", ()=>{
  if(!state.selectedCutId) return alert("컷을 먼저 선택하세요.");
  const cut = state.cuts[state.selectedCutId];
  cutCharHint.textContent = `저장됨 ✅ 등장 캐릭터: ${cut.cutChars.length ? cut.cutChars.join(", ") : "(없음)"}`;
  cut.renderCache = null;
});

/** =========================
 *  EXPORT JSON
 *  ========================= */
function buildPaletteJson(){
  const out = { version:4, episodeId: state.episodeId, characters:{} };
  for(const [code, c] of Object.entries(state.characters)){
    out.characters[code] = { displayName: c.displayName || code, palette: c.palette };
  }
  return out;
}
function buildEpisodeMetaJson(){
  const out = { episodeId: state.episodeId, cuts:{} };
  for(const cutId of state.cutOrder){
    const c = state.cuts[cutId];
    out.cuts[cutId] = { y0: c.y0, y1: c.y1, chars: c.cutChars || [] };
  }
  return out;
}
btnExportPalette.addEventListener("click", ()=>downloadJson(buildPaletteJson(), "palette.json"));
btnExportMeta.addEventListener("click", ()=>downloadJson(buildEpisodeMetaJson(), "episode.meta.json"));

/** =========================
 *  RENDER BUTTONS
 *  ========================= */
btnRender.addEventListener("click", async ()=>{
  if(!state.selectedCutId) return alert("컷을 먼저 선택하세요.");
  const cut = state.cuts[state.selectedCutId];
  if(cut.cutChars.length === 0) return alert("현재 컷 등장 캐릭터를 체크하세요.");

  setStatus("렌더 중…");
  const result = await renderCutAuto(state.selectedCutId);

  cvOut.width = 900; cvOut.height = 600;
  drawContain(cvOut.getContext("2d"), result.outCanvas, cvOut);

  cvDbg.width = 900; cvDbg.height = 600;
  drawContain(cvDbg.getContext("2d"), result.dbgCanvas, cvDbg);

  renderHint.innerHTML =
    `렌더 완료 ✅ region ${result.regionCount} / cand ${result.candCount} / fill ${result.filledCount}<br/>`+
    `faceId: ${result.faceCount} / neckSkin: ${result.neckCount} / armSkin: ${result.armCount}`;
  setStatus("렌더 OK");
});

/** =========================
 *  COLOR DILATION (problem2 white gaps)
 *  ========================= */
function dilateColorCanvas(srcCanvas, rad=2){
  const W = srcCanvas.width, H = srcCanvas.height;
  const sctx = srcCanvas.getContext("2d");
  const src = sctx.getImageData(0,0,W,H);
  const d = src.data;

  const out = new ImageData(W,H);
  const od = out.data;
  od.set(d);

  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const i=(y*W+x)*4;
      if(d[i+3]===0) continue;
      const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];

      for(let dy=-rad; dy<=rad; dy++){
        const yy=y+dy; if(yy<0||yy>=H) continue;
        for(let dx=-rad; dx<=rad; dx++){
          const xx=x+dx; if(xx<0||xx>=W) continue;
          const j=(yy*W+xx)*4;
          if(od[j+3]===0){
            od[j]=r; od[j+1]=g; od[j+2]=b; od[j+3]=a;
          }
        }
      }
    }
  }

  const c = document.createElement("canvas");
  c.width=W; c.height=H;
  c.getContext("2d").putImageData(out,0,0);
  return c;
}

/** =========================
 *  AUTO FLAT (v4: face-neck + arm skin)
 *  ========================= */
async function renderCutAuto(cutId){
  const cut = state.cuts[cutId];
  if(cut.renderCache) return cut.renderCache;

  const src = cut.cropCanvas;
  const sw = src.width, sh = src.height;

  const targetW = 520;
  const s = Math.min(1, targetW / sw);
  const aw = Math.max(220, Math.floor(sw*s));
  const ah = Math.max(220, Math.floor(sh*s));

  const a = document.createElement("canvas");
  a.width = aw; a.height = ah;
  const actx = a.getContext("2d");
  actx.drawImage(src, 0, 0, aw, ah);

  const img = actx.getImageData(0,0,aw,ah);
  const d = img.data;

  // line mask
  const line = new Uint8Array(aw*ah);
  for(let i=0;i<aw*ah;i++){
    const r=d[i*4], g=d[i*4+1], b=d[i*4+2], alpha=d[i*4+3];
    if(alpha===0){ line[i]=0; continue; }
    const lum = (r+g+b)/3;
    line[i] = (lum < 225) ? 1 : 0;
  }

  // dilate lines for closure
  const dil = new Uint8Array(aw*ah);
  const rad = 3;
  for(let y=0;y<ah;y++){
    for(let x=0;x<aw;x++){
      let v = 0;
      for(let dy=-rad; dy<=rad; dy++){
        const yy=y+dy; if(yy<0||yy>=ah) continue;
        for(let dx=-rad; dx<=rad; dx++){
          const xx=x+dx; if(xx<0||xx>=aw) continue;
          if(line[yy*aw+xx]){ v=1; break; }
        }
        if(v) break;
      }
      dil[y*aw+x]=v;
    }
  }

  // region labeling on non-line pixels
  const label = new Int32Array(aw*ah);
  label.fill(-1);

  const regions = []; // {id, area, cx, cy, touchesBorder, bbox}
  let rid = 0;

  const qx = new Int32Array(aw*ah);
  const qy = new Int32Array(aw*ah);

  function pushRegion(seedX, seedY){
    let qs=0, qe=0;
    qx[qe]=seedX; qy[qe]=seedY; qe++;
    label[seedY*aw+seedX]=rid;

    let area=0, sumx=0, sumy=0;
    let touchesBorder = (seedX===0||seedY===0||seedX===aw-1||seedY===ah-1);
    let minx=seedX, maxx=seedX, miny=seedY, maxy=seedY;

    while(qs<qe){
      const x = qx[qs], y = qy[qs]; qs++;
      area++; sumx+=x; sumy+=y;
      if(x===0||y===0||x===aw-1||y===ah-1) touchesBorder=true;
      if(x<minx)minx=x; if(x>maxx)maxx=x;
      if(y<miny)miny=y; if(y>maxy)maxy=y;

      const n = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
      for(const [nx,ny] of n){
        if(nx<0||ny<0||nx>=aw||ny>=ah) continue;
        const idx = ny*aw+nx;
        if(dil[idx]===1) continue;
        if(label[idx]!==-1) continue;
        label[idx]=rid;
        qx[qe]=nx; qy[qe]=ny; qe++;
      }
    }

    regions.push({
      id: rid,
      area,
      cx: sumx/area,
      cy: sumy/area,
      touchesBorder,
      bbox: {minx, miny, maxx, maxy}
    });
    rid++;
  }

  for(let y=0;y<ah;y++){
    for(let x=0;x<aw;x++){
      const idx=y*aw+x;
      if(dil[idx]===1) continue;
      if(label[idx]!==-1) continue;
      pushRegion(x,y);
    }
  }

  // adjacency graph between regions (for face->neck / top->arms)
  const adj = new Map(); // id -> Set(id)
  function link(a,b){
    if(a===b || a<0 || b<0) return;
    let sa = adj.get(a); if(!sa){ sa=new Set(); adj.set(a,sa); }
    let sb = adj.get(b); if(!sb){ sb=new Set(); adj.set(b,sb); }
    sa.add(b); sb.add(a);
  }
  for(let y=0;y<ah;y++){
    for(let x=0;x<aw;x++){
      const idx = y*aw+x;
      const aId = label[idx];
      if(aId<0) continue;
      if(x+1<aw){
        const bId = label[idx+1];
        if(bId>=0 && bId!==aId) link(aId,bId);
      }
      if(y+1<ah){
        const cId = label[idx+aw];
        if(cId>=0 && cId!==aId) link(aId,cId);
      }
    }
  }

  // background = ALL border-touching regions
  const bgSet = new Set();
  for(const r of regions){
    if(r.touchesBorder) bgSet.add(r.id);
  }

  const minArea = Math.max(80, Math.floor((aw*ah) * 0.00025));
  const cand = regions.filter(r => !bgSet.has(r.id) && r.area >= minArea);

  // group by x using K-means
  const charCodes = [...cut.cutChars];
  let K = Math.max(1, Math.min(charCodes.length, 5));

  const xs = cand.map(r=>r.cx);
  const xSpread = (xs.length? (Math.max(...xs)-Math.min(...xs)) : 0);
  if(K===2 && xSpread < aw*0.22) K = 1;

  const km = kmeans1D(xs, K);
  const groups = Array.from({length:K}, ()=>[]);
  for(let i=0;i<cand.length;i++){
    groups[km.labels[i]].push(cand[i]);
  }

  const order = [...Array(K).keys()].sort((a,b)=>km.centers[a]-km.centers[b]);
  const groupToChar = (gIndex)=> charCodes[Math.min(order.indexOf(gIndex), charCodes.length-1)];

  // group bboxes
  const groupBBox = groups.map(gs=>{
    let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
    if(gs.length===0){ minx=0;miny=0;maxx=aw-1;maxy=ah-1; }
    for(const r of gs){
      minx=Math.min(minx,r.bbox.minx); miny=Math.min(miny,r.bbox.miny);
      maxx=Math.max(maxx,r.bbox.maxx); maxy=Math.max(maxy,r.bbox.maxy);
    }
    return {minx,miny,maxx,maxy};
  });

  function getColorFor(charCode, part){
    const ch = state.characters[charCode];
    const fallback = {
      bg:"#ffffff",
      skin:"#f0d2c2",
      hair:"#1a1410",
      brow:"#2a2320",
      eye_iris:"#3a6ea5",
      eye_white:"#ffffff",
      mouth:"#c7867a",
      top:"#b1e0fe",
      bottom:"#2e78a7"
    };
    if(!ch || !ch.palette) return fallback[part] || "#cccccc";
    const e = ch.palette[part];
    return (e && e.hex) ? e.hex : (fallback[part] || "#cccccc");
  }

  /** -------------------------
   *  v4: FACE → NECK SKIN + TOP → ARM SKIN
   *  For each group, precompute:
   *    faceId (best face candidate)
   *    neckSkinSet (adjacent chain below face)
   *    topId (best top candidate)
   *    armSkinSet (adjacent side regions to top)
   * ------------------------- */
  const faceIds = new Set();
  const neckSkinIds = new Set();
  const topIds = new Set();
  const armSkinIds = new Set();

  // quick lookup by id
  const regionById = new Map(regions.map(r=>[r.id, r]));
  function relMetrics(r, bb){
    const gh = Math.max(1, bb.maxy - bb.miny);
    const gw = Math.max(1, bb.maxx - bb.minx);
    const relY = (r.cy - bb.miny) / gh;
    const relX = (r.cx - bb.minx) / gw;
    const relH = (r.bbox.maxy - r.bbox.miny) / gh;
    const relW = (r.bbox.maxx - r.bbox.minx) / gw;
    const areaRel = r.area / Math.max(1, (bb.maxx-bb.minx)*(bb.maxy-bb.miny));
    return {relY, relX, relH, relW, areaRel, gh, gw};
  }

  for(let gi=0; gi<K; gi++){
    const code = groupToChar(gi);
    const bb = groupBBox[gi];
    const gs = groups[gi];
    const pal = state.characters[code]?.palette || {};

    const groupSet = new Set(gs.map(r=>r.id));
    const gw = Math.max(1, bb.maxx-bb.minx);
    const gh = Math.max(1, bb.maxy-bb.miny);

    // 1) find face candidate
    let bestFace = null;
    let bestScore = -1e9;
    for(const r of gs){
      const m = relMetrics(r, bb);

      // face band: upper-middle
      const inBand = (m.relY > 0.16 && m.relY < 0.55);
      if(!inBand) continue;

      // face size constraints (too small/too big 제외)
      if(m.areaRel < 0.006 || m.areaRel > 0.15) continue;

      // aspect constraint (너무 긴 것 제외)
      const asp = (m.relW / Math.max(1e-6, m.relH));
      if(asp < 0.45 || asp > 2.2) continue;

      // score:
      // - prefer near center X
      // - prefer not too wide
      // - prefer moderate area
      const centerScore = 1.0 - Math.abs(m.relX - 0.50);
      const sizeScore = 1.0 - Math.abs(m.areaRel - 0.05); // 0.05 근처 선호
      const slimPenalty = Math.abs(asp - 1.0);

      let s = 0;
      s += centerScore * 2.2;
      s += sizeScore * 1.4;
      s -= slimPenalty * 0.45;

      // if skin palette exists, boost (to trust skin logic)
      if(pal.skin) s += 0.35;

      if(s > bestScore){ bestScore=s; bestFace=r; }
    }

    if(bestFace){
      faceIds.add(bestFace.id);

      // 2) neck skin: BFS from face into adjacent regions,
      // only those BELOW face and close in X range
      const fx0 = bestFace.bbox.minx, fx1 = bestFace.bbox.maxx;
      const fy1 = bestFace.bbox.maxy;
      const xPad = Math.floor(gw * 0.10);

      const allowX0 = fx0 - xPad;
      const allowX1 = fx1 + xPad;
      const maxNeckY = bestFace.cy + gh*0.38;

      const visited = new Set([bestFace.id]);
      const q = [bestFace.id];

      while(q.length){
        const cur = q.shift();
        const neigh = adj.get(cur);
        if(!neigh) continue;
        for(const nid of neigh){
          if(visited.has(nid)) continue;
          if(bgSet.has(nid)) continue;
          if(!groupSet.has(nid)) continue;

          const nr = regionById.get(nid);
          if(!nr) continue;

          // must be under face-ish and near x-range
          const under = (nr.cy >= fy1-2);
          const withinX = (nr.bbox.maxx >= allowX0 && nr.bbox.minx <= allowX1);
          const notTooLow = (nr.cy <= maxNeckY);

          // exclude huge body area (상의/몸통)
          const m = relMetrics(nr, bb);
          const notHuge = (m.areaRel <= 0.22);

          if(under && withinX && notTooLow && notHuge){
            neckSkinIds.add(nid);
            visited.add(nid);
            q.push(nid);
          }else{
            visited.add(nid);
          }
        }
      }
    }

    // 3) find top candidate (largest in torso band)
    let bestTop = null;
    let bestTopScore = -1e9;
    for(const r of gs){
      const m = relMetrics(r, bb);
      // torso band
      if(m.relY < 0.48 || m.relY > 0.90) continue;
      // big-ish
      if(m.areaRel < 0.03) continue;

      // score mainly by area, slightly by center
      const centerScore = 1.0 - Math.abs(m.relX - 0.5);
      let s = (m.areaRel * 10.0) + centerScore*0.5;

      if(pal.top) s += 0.25;

      if(s>bestTopScore){ bestTopScore=s; bestTop=r; }
    }
    if(bestTop){
      topIds.add(bestTop.id);

      // 4) arm skin: regions adjacent to top that extend sideways beyond top bbox
      const tb = bestTop.bbox;
      const torsoH = Math.max(1, tb.maxy - tb.miny);
      const torsoW = Math.max(1, tb.maxx - tb.minx);

      const nset = adj.get(bestTop.id) || new Set();
      for(const nid of nset){
        if(bgSet.has(nid)) continue;
        if(!groupSet.has(nid)) continue;
        const nr = regionById.get(nid);
        if(!nr) continue;

        const m = relMetrics(nr, bb);
        // must overlap vertically with torso a decent amount
        const ov = overlap1D(nr.bbox.miny, nr.bbox.maxy, tb.miny, tb.maxy);
        const ovRatio = ov / Math.max(1, Math.min(nr.bbox.maxy-nr.bbox.miny, torsoH));
        if(ovRatio < 0.35) continue;

        // must be in mid-lower band (arms)
        if(m.relY < 0.38 || m.relY > 0.92) continue;

        // must be not huge
        if(m.areaRel > 0.18) continue;

        // side condition: extend outside torso bbox on left or right
        const leftSide = (nr.bbox.maxx < tb.minx + torsoW*0.20);
        const rightSide = (nr.bbox.minx > tb.maxx - torsoW*0.20);
        const extendsLeft = (nr.bbox.minx < tb.minx - torsoW*0.06);
        const extendsRight = (nr.bbox.maxx > tb.maxx + torsoW*0.06);

        const isSide = (leftSide && extendsLeft) || (rightSide && extendsRight);
        if(!isSide) continue;

        armSkinIds.add(nid);
      }
    }
  }

  // classification
  function classifyPart(region, bb, charCode){
    // v4 overrides first
    if(faceIds.has(region.id)) return "skin";
    if(neckSkinIds.has(region.id)) return "skin";
    if(armSkinIds.has(region.id)) return "skin";

    // fallback heuristic
    const relY = (region.cy - bb.miny) / Math.max(1, (bb.maxy - bb.miny));
    const relH = (region.bbox.maxy - region.bbox.miny) / Math.max(1, (bb.maxy - bb.miny));
    const relW = (region.bbox.maxx - region.bbox.minx) / Math.max(1, (bb.maxx - bb.minx));
    const areaRel = region.area / Math.max(1, (bb.maxx-bb.minx)*(bb.maxy-bb.miny));

    const pal = state.characters[charCode]?.palette || {};

    const isEyeish = (relY > 0.18 && relY < 0.45) && (areaRel < 0.030) && (relH < 0.22) && (relW < 0.28);
    if(isEyeish){
      if(pal["eye_iris"] && pal["eye_white"]){
        return (areaRel < 0.010) ? "eye_iris" : "eye_white";
      }
      if(pal["eye_iris"]) return "eye_iris";
      if(pal["eye_white"]) return "eye_white";
    }

    const isBrowish = (relY > 0.10 && relY < 0.28) && relH < 0.10 && areaRel < 0.020;
    if(isBrowish && pal["brow"]) return "brow";

    const isMouthish = (relY > 0.45 && relY < 0.68) && areaRel < 0.020 && relH < 0.1212;
    if(isMouthish && pal["mouth"]) return "mouth";

    // main bands
    if(relY < 0.22) return "hair";
    if(relY < 0.56) return "skin";
    if(relY < 0.82) return "top";
    return "bottom";
  }

  // regionId -> meta
  const regionMeta = new Map();
  for(let gi=0; gi<K; gi++){
    const code = groupToChar(gi);
    for(const r of groups[gi]){
      const part = classifyPart(r, groupBBox[gi], code);
      const hex = getColorFor(code, part);
      regionMeta.set(r.id, {code, part, hex});
    }
  }

  // bg fill (white default or palette bg)
  let bgHex = "#ffffff";
  for(const code of charCodes){
    const pal = state.characters[code]?.palette;
    if(pal?.bg?.hex){ bgHex = pal.bg.hex; break; }
  }

  // build color at analysis res
  const color = document.createElement("canvas");
  color.width = aw; color.height = ah;
  const cctx = color.getContext("2d");
  cctx.fillStyle = bgHex;
  cctx.fillRect(0,0,aw,ah);

  const outImg = cctx.getImageData(0,0,aw,ah);
  const od = outImg.data;

  const uniqueFilled = new Set();
  for(let y=0;y<ah;y++){
    for(let x=0;x<aw;x++){
      const idx = y*aw+x;
      const lid = label[idx];
      if(lid < 0) continue;
      if(bgSet.has(lid)) continue;

      const meta = regionMeta.get(lid);
      if(!meta) continue;

      const {r,g,b} = hexToRgb(meta.hex);
      const o = idx*4;
      od[o]=r; od[o+1]=g; od[o+2]=b; od[o+3]=255;
      uniqueFilled.add(lid);
    }
  }
  cctx.putImageData(outImg,0,0);

  // ✅ v4: reduce white gaps around line by dilating colors slightly
  const color2 = dilateColorCanvas(color, 2);

  // overlay lineart
  const overlay = document.createElement("canvas");
  overlay.width = aw; overlay.height = ah;
  const octx = overlay.getContext("2d");
  octx.drawImage(a,0,0);
  const li = octx.getImageData(0,0,aw,ah);
  const ld = li.data;
  for(let i=0;i<aw*ah;i++){
    const lum = (ld[i*4]+ld[i*4+1]+ld[i*4+2])/3;
    if(lum < 205){
      ld[i*4]=0; ld[i*4+1]=0; ld[i*4+2]=0; ld[i*4+3]=255;
    }else{
      ld[i*4+3]=0;
    }
  }
  octx.putImageData(li,0,0);

  // compose final at original res (bg fixed)
  const out = document.createElement("canvas");
  out.width = sw; out.height = sh;
  const outCtx = out.getContext("2d");

  outCtx.fillStyle = bgHex;
  outCtx.fillRect(0,0,sw,sh);

  outCtx.imageSmoothingEnabled = false;
  outCtx.drawImage(color2, 0,0, sw,sh);
  outCtx.imageSmoothingEnabled = true;
  outCtx.drawImage(overlay, 0,0, sw,sh);

  // debug canvas at analysis res
  const dbg = document.createElement("canvas");
  dbg.width = aw; dbg.height = ah;
  const dbgCtx = dbg.getContext("2d");
  dbgCtx.fillStyle="#ffffff"; dbgCtx.fillRect(0,0,aw,ah);
  dbgCtx.drawImage(color2,0,0);

  // draw group boxes
  for(let gi=0; gi<K; gi++){
    const bb = groupBBox[gi];
    const col = ["#79a7ff","#35d07f","#ffd38a","#ff5a6a","#c48bff"][gi%5];
    dbgCtx.strokeStyle = col;
    dbgCtx.lineWidth = 2;
    dbgCtx.strokeRect(bb.minx, bb.miny, bb.maxx-bb.minx, bb.maxy-bb.miny);
    dbgCtx.fillStyle = col;
    dbgCtx.font = "12px monospace";
    dbgCtx.fillText(groupToChar(gi), bb.minx+4, bb.miny+14);
  }

  // highlight face/neck/arm ids (simple overlay rectangles)
  function markIds(idSet, stroke){
    dbgCtx.strokeStyle = stroke;
    dbgCtx.lineWidth = 2;
    for(const id of idSet){
      const r = regionById.get(id);
      if(!r) continue;
      dbgCtx.strokeRect(r.bbox.minx, r.bbox.miny, r.bbox.maxx-r.bbox.minx, r.bbox.maxy-r.bbox.miny);
    }
  }
  markIds(faceIds, "#00d4ff");     // face = cyan
  markIds(neckSkinIds, "#00ff7a"); // neck skin = green
  markIds(armSkinIds, "#ff9f00");  // arm skin = orange

  const cache = {
    outCanvas: out,
    dbgCanvas: dbg,
    regionCount: regions.length,
    candCount: cand.length,
    filledCount: uniqueFilled.size,
    faceCount: faceIds.size,
    neckCount: neckSkinIds.size,
    armCount: armSkinIds.size
  };
  cut.renderCache = cache;
  return cache;
}

/** =========================
 *  DOWNLOAD
 *  ========================= */
btnDownloadCut.addEventListener("click", async ()=>{
  if(!state.selectedCutId) return alert("컷을 먼저 선택하세요.");
  const blob = await renderCutToPNGBlob(state.selectedCutId);
  saveAs(blob, `${state.selectedCutId}_colored.png`);
});
btnDownloadAll.addEventListener("click", async ()=>{
  if(state.cutOrder.length === 0) return alert("컷이 없습니다. 먼저 자동 컷 분할을 하세요.");
  setStatus("ZIP 생성 중…");
  const zip = new JSZip();
  for(const cutId of state.cutOrder){
    const blob = await renderCutToPNGBlob(cutId);
    zip.file(`${cutId}_colored.png`, blob);
  }
  zip.file(`palette.json`, JSON.stringify(buildPaletteJson(), null, 2));
  zip.file(`episode.meta.json`, JSON.stringify(buildEpisodeMetaJson(), null, 2));
  const out = await zip.generateAsync({type:"blob"});
  saveAs(out, `${state.episodeId}_colored.zip`);
  setStatus("ZIP OK");
});
async function renderCutToPNGBlob(cutId){
  const res = await renderCutAuto(cutId);
  return new Promise(resolve => res.outCanvas.toBlob(resolve, "image/png"));
}

/** =========================
 *  INIT
 *  ========================= */
renderPartsUI();
refreshCharSelect();
setStatus("대기");
</script>
</body>
</html>
